package pgsql

import (
	"context"
	"database/sql"
	"fmt"

	knowledge "github.com/CodeClarityCE/utility-types/knowledge_db"
	"github.com/google/uuid"
	"github.com/uptrace/bun"
)

// deduplicateOsvPackageVulnerabilities removes duplicate entries for OSV-based vulnerabilities.
func deduplicateOsvPackageVulnerabilities(items []knowledge.PackageVulnerability) []knowledge.PackageVulnerability {
	seen := make(map[string]int)
	result := make([]knowledge.PackageVulnerability, 0, len(items))

	for _, item := range items {
		if item.OsvId == nil {
			continue
		}
		key := fmt.Sprintf("%s|%s|%s", item.PackageName, item.PackageEcosystem, item.OsvId.String())
		if idx, exists := seen[key]; exists {
			result[idx] = item
		} else {
			seen[key] = len(result)
			result = append(result, item)
		}
	}

	return result
}

// deduplicateNvdPackageVulnerabilities removes duplicate entries for NVD-based vulnerabilities.
func deduplicateNvdPackageVulnerabilities(items []knowledge.PackageVulnerability) []knowledge.PackageVulnerability {
	seen := make(map[string]int)
	result := make([]knowledge.PackageVulnerability, 0, len(items))

	for _, item := range items {
		if item.NvdId == nil {
			continue
		}
		key := fmt.Sprintf("%s|%s|%s", item.PackageName, item.PackageEcosystem, item.NvdId.String())
		if idx, exists := seen[key]; exists {
			result[idx] = item
		} else {
			seen[key] = len(result)
			result = append(result, item)
		}
	}

	return result
}

// BatchInsertOsvPackageVulnerabilities inserts OSV-based package-vulnerability links.
func BatchInsertOsvPackageVulnerabilities(db *bun.DB, items []knowledge.PackageVulnerability) error {
	if len(items) == 0 {
		return nil
	}

	items = deduplicateOsvPackageVulnerabilities(items)
	if len(items) == 0 {
		return nil
	}

	ctx := context.Background()

	tx, err := db.BeginTx(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	// Use ON CONFLICT DO NOTHING since the partial unique index handles duplicates
	_, err = tx.NewInsert().
		Model(&items).
		On("CONFLICT (package_name, package_ecosystem, osv_id) WHERE osv_id IS NOT NULL DO NOTHING").
		Exec(ctx)

	if err != nil {
		return fmt.Errorf("failed to batch insert %d OSV package vulnerability records: %w", len(items), err)
	}

	if err = tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	return nil
}

// BatchInsertNvdPackageVulnerabilities inserts NVD-based package-vulnerability links.
func BatchInsertNvdPackageVulnerabilities(db *bun.DB, items []knowledge.PackageVulnerability) error {
	if len(items) == 0 {
		return nil
	}

	items = deduplicateNvdPackageVulnerabilities(items)
	if len(items) == 0 {
		return nil
	}

	ctx := context.Background()

	tx, err := db.BeginTx(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	_, err = tx.NewInsert().
		Model(&items).
		On("CONFLICT (package_name, package_ecosystem, nvd_id) WHERE nvd_id IS NOT NULL DO NOTHING").
		Exec(ctx)

	if err != nil {
		return fmt.Errorf("failed to batch insert %d NVD package vulnerability records: %w", len(items), err)
	}

	if err = tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	return nil
}

// deduplicateFriendsOfPhpPackageVulnerabilities removes duplicate entries for FriendsOfPHP-based vulnerabilities.
func deduplicateFriendsOfPhpPackageVulnerabilities(items []knowledge.PackageVulnerability) []knowledge.PackageVulnerability {
	seen := make(map[string]int)
	result := make([]knowledge.PackageVulnerability, 0, len(items))

	for _, item := range items {
		if item.FriendsOfPhpId == nil {
			continue
		}
		key := fmt.Sprintf("%s|%s|%s", item.PackageName, item.PackageEcosystem, item.FriendsOfPhpId.String())
		if idx, exists := seen[key]; exists {
			result[idx] = item
		} else {
			seen[key] = len(result)
			result = append(result, item)
		}
	}

	return result
}

// BatchInsertFriendsOfPhpPackageVulnerabilities inserts FriendsOfPHP-based package-vulnerability links.
func BatchInsertFriendsOfPhpPackageVulnerabilities(db *bun.DB, items []knowledge.PackageVulnerability) error {
	if len(items) == 0 {
		return nil
	}

	items = deduplicateFriendsOfPhpPackageVulnerabilities(items)
	if len(items) == 0 {
		return nil
	}

	ctx := context.Background()

	tx, err := db.BeginTx(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to begin transaction: %w", err)
	}
	defer tx.Rollback()

	_, err = tx.NewInsert().
		Model(&items).
		On("CONFLICT (package_name, package_ecosystem, friendsofphp_id) WHERE friendsofphp_id IS NOT NULL DO NOTHING").
		Exec(ctx)

	if err != nil {
		return fmt.Errorf("failed to batch insert %d FriendsOfPHP package vulnerability records: %w", len(items), err)
	}

	if err = tx.Commit(); err != nil {
		return fmt.Errorf("failed to commit transaction: %w", err)
	}

	return nil
}

// GetVulnerabilitiesForPackage retrieves all vulnerability links for a specific package.
func GetVulnerabilitiesForPackage(db *bun.DB, packageName string, ecosystem string) ([]knowledge.PackageVulnerability, error) {
	ctx := context.Background()

	var vulns []knowledge.PackageVulnerability
	err := db.NewSelect().
		Model(&vulns).
		Where("package_name = ?", packageName).
		Where("package_ecosystem = ?", ecosystem).
		Scan(ctx)

	if err != nil {
		if err == sql.ErrNoRows {
			return []knowledge.PackageVulnerability{}, nil
		}
		return nil, fmt.Errorf("failed to retrieve vulnerabilities for package %s (%s): %w", packageName, ecosystem, err)
	}

	return vulns, nil
}

// GetVulnerabilitiesForPackages retrieves vulnerability links for multiple packages.
func GetVulnerabilitiesForPackages(db *bun.DB, packages []struct {
	Name      string
	Ecosystem string
}) ([]knowledge.PackageVulnerability, error) {
	if len(packages) == 0 {
		return []knowledge.PackageVulnerability{}, nil
	}

	ctx := context.Background()

	var vulns []knowledge.PackageVulnerability

	query := db.NewSelect().Model(&vulns)

	for i, pkg := range packages {
		if i == 0 {
			query = query.Where("(package_name = ? AND package_ecosystem = ?)", pkg.Name, pkg.Ecosystem)
		} else {
			query = query.WhereOr("(package_name = ? AND package_ecosystem = ?)", pkg.Name, pkg.Ecosystem)
		}
	}

	err := query.Scan(ctx)
	if err != nil {
		if err == sql.ErrNoRows {
			return []knowledge.PackageVulnerability{}, nil
		}
		return nil, fmt.Errorf("failed to retrieve vulnerabilities for packages: %w", err)
	}

	return vulns, nil
}

// GetOsvIdsForPackage retrieves OSV UUIDs for a specific package.
func GetOsvIdsForPackage(db *bun.DB, packageName string, ecosystem string) ([]uuid.UUID, error) {
	ctx := context.Background()

	var ids []uuid.UUID
	err := db.NewSelect().
		TableExpr("package_vulnerability").
		Column("osv_id").
		Where("package_name = ?", packageName).
		Where("package_ecosystem = ?", ecosystem).
		Where("osv_id IS NOT NULL").
		Scan(ctx, &ids)

	if err != nil {
		if err == sql.ErrNoRows {
			return []uuid.UUID{}, nil
		}
		return nil, fmt.Errorf("failed to retrieve OSV IDs for package %s (%s): %w", packageName, ecosystem, err)
	}

	return ids, nil
}
